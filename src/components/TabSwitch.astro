---
// Tab switching functionality for expressive-code tabs
---

<script>
  class ExpressiveCodeTabs {
    static init() {
      this.bindTabEvents()
    }

    static bindTabEvents() {
      // Find all expressive-code containers with potential tab structures
      const codeContainers = document.querySelectorAll('.expressive-code')
      
      codeContainers.forEach(container => {
        // Look for tab-like structures in expressive-code
        // This handles both current and future tab implementations
        
        // Method 1: Handle standard ARIA tab pattern
        const tabList = container.querySelector('[role="tablist"]')
        if (tabList) {
          const tabs = tabList.querySelectorAll('[role="tab"]')
          const panels = container.querySelectorAll('[role="tabpanel"]')
          this.bindTabInteractions(tabs, panels)
        }
        
        // Method 2: Handle header-based tab switching (for file groups)
        const headers = container.querySelectorAll('.header .title')
        if (headers.length > 1) {
          // Multiple titles could indicate tab groups
          this.bindHeaderTabs(container, headers)
        }

        // Method 3: Handle any clickable tab-like elements
        const tabElements = container.querySelectorAll('.tab, [data-tab], .ec-tab')
        if (tabElements.length > 0) {
          this.bindGenericTabs(container, tabElements)
        }
      })
    }

    static bindTabInteractions(tabs: NodeListOf<Element>, panels: NodeListOf<Element>) {
      tabs.forEach((tab: Element, index: number) => {
        tab.addEventListener('click', (e: Event) => {
          e.preventDefault()
          this.switchTab(tabs, panels, index)
        })

        // Add keyboard support
        tab.addEventListener('keydown', (e) => {
          if ((e as KeyboardEvent).key === 'Enter' || (e as KeyboardEvent).key === ' ') {
            e.preventDefault()
            this.switchTab(tabs, panels, index)
          } else if ((e as KeyboardEvent).key === 'ArrowRight' || (e as KeyboardEvent).key === 'ArrowLeft') {
            e.preventDefault()
            const direction = (e as KeyboardEvent).key === 'ArrowRight' ? 1 : -1
            const newIndex = (index + direction + tabs.length) % tabs.length
            ;(tabs[newIndex] as HTMLElement).focus()
            this.switchTab(tabs, panels, newIndex)
          }
        })
      })
    }

    static bindHeaderTabs(container: Element, headers: NodeListOf<Element>) {
      // This is for potential future file group implementations
      headers.forEach((header: Element, index: number) => {
        if (!header.hasAttribute('data-tab-enabled')) {
          header.setAttribute('data-tab-enabled', 'true')
          ;(header as HTMLElement).style.cursor = 'pointer'
          header.setAttribute('tabindex', '0')
          header.setAttribute('role', 'tab')
          
          header.addEventListener('click', () => {
            this.switchHeaderTab(container, headers, index)
          })
          
          header.addEventListener('keydown', (e) => {
            if ((e as KeyboardEvent).key === 'Enter' || (e as KeyboardEvent).key === ' ') {
              e.preventDefault()
              this.switchHeaderTab(container, headers, index)
            }
          })
        }
      })
    }

    static bindGenericTabs(container: Element, tabElements: NodeListOf<Element>) {
      tabElements.forEach((tab: Element, index: number) => {
        tab.addEventListener('click', (e: Event) => {
          e.preventDefault()
          // Find associated content
          const contentId = tab.getAttribute('data-tab-content') || 
                           tab.getAttribute('aria-controls')
          if (contentId) {
            const content = document.getElementById(contentId)
            if (content) {
              this.switchGenericTab(tabElements, content, index)
            }
          }
        })
      })
    }

    static switchTab(tabs: NodeListOf<Element>, panels: NodeListOf<Element>, activeIndex: number) {
      // Update tab states
      tabs.forEach((tab: Element, index: number) => {
        const isActive = index === activeIndex
        tab.setAttribute('aria-selected', isActive.toString())
        tab.setAttribute('tabindex', isActive ? '0' : '-1')
        
        // Update visual states
        tab.classList.toggle('active', isActive)
        tab.classList.toggle('inactive', !isActive)
      })

      // Update panel states
      panels.forEach((panel, index: number) => {
        const isActive = index === activeIndex
        ;(panel as HTMLElement).setAttribute('aria-hidden', (!isActive).toString())
        ;(panel as HTMLElement).hidden = !isActive
        
        // Update visual states
        ;(panel as HTMLElement).style.display = isActive ? 'block' : 'none'
      })
    }

    static switchHeaderTab(container: Element, headers: NodeListOf<Element>, activeIndex: number) {
      // Handle header-based tab switching
      headers.forEach((header: Element, index: number) => {
        const isActive = index === activeIndex
        header.setAttribute('aria-selected', isActive.toString())
        header.classList.toggle('active', isActive)
        
        // Find associated figure/content
        const figure = header.closest('figure') || header.parentElement
        if (figure) {
          const allFigures = container.querySelectorAll('figure')
          allFigures.forEach((fig: HTMLElement, figIndex: number) => {
            if (figIndex === activeIndex) {
              fig.style.display = 'block'
              fig.setAttribute('aria-hidden', 'false')
            } else {
              fig.style.display = 'none'
              fig.setAttribute('aria-hidden', 'true')
            }
          })
        }
      })
    }

    static switchGenericTab(tabs: NodeListOf<Element>, content: HTMLElement, activeIndex: number) {
      tabs.forEach((tab: Element, index: number) => {
        tab.classList.toggle('active', index === activeIndex)
        tab.setAttribute('aria-selected', (index === activeIndex).toString())
      })
      
      // Show associated content
      const allContents = document.querySelectorAll('[data-tab-content]')
      allContents.forEach((c) => (c as HTMLElement).style.display = 'none')
      content.style.display = 'block'
    }

    static cleanup() {
      // Remove event listeners during navigation
      const tabs = document.querySelectorAll('.expressive-code [role="tab"], .expressive-code .header .title[data-tab-enabled]')
      tabs.forEach(tab => {
        // Clone node to remove all event listeners
        const newTab = tab.cloneNode(true)
        tab.parentNode?.replaceChild(newTab, tab)
      })
    }
  }

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    ExpressiveCodeTabs.init()
  })

  // Re-initialize on Astro page navigation
  document.addEventListener('astro:page-load', () => {
    ExpressiveCodeTabs.init()
  })

  // Cleanup before page swap
  document.addEventListener('astro:before-swap', () => {
    ExpressiveCodeTabs.cleanup()
  })

  // Re-initialize after page swap
  document.addEventListener('astro:after-swap', () => {
    ExpressiveCodeTabs.init()
  })
</script>